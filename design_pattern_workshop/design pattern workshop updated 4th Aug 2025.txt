Top 10 Java books
------------------
Head first core java
Head first design pattern
Head first OOAD
java 8 in action
java interview companion arulkumaran
effective java
clean code
scjp kathy sierra
data structure and algorithms in java by robert lafore 
Designing Data-Intensive Applications




Deep Dive design pattern with java
-----------------------------------
	=> Understanding abs, encapsulation
	=> When to go for interface, when to go for abstract class?
	=> What and Why design pattern
	=> loose coupling and high cohesion, using interface, 
	composition, aggrigation, inheritance, basic of uml
 
	=> Design Principles (SOLID)

	=> GOF Pattern categories

	=>selected design pattern

	"proven way of doing thing"
	
	
	=> Creational Patterns
		Singleton
		Factory
		Abstract Factory
		Builder
		Prototype

	=> Structural Patterns
		Adapter
		Decorator
		Facade Pattern
		Bridge
		Composite
		Flyweight
		Proxy

	=> Behavioral Patterns
		Chain of Responsibility
		Command
		Interpreter
		Iterator
		Mediator
		Memento
		Observer
		Strategy
		Template Method


	
Understanding Abstraction & encapsulation:
------------------------------------------

 class Cat {
	private String regId;
	private String ownerName;
	private int numberOfBonesFractured;
	private String deseaseHistory;
	private	double consultancyFee;
	
	String name;
	String favouriteFood;
	Date dob;	
}


Understanding Abstraction:
----------------------

Need of Method abst:
---------------------
class StackImpUsingArray {
	private int x[];
	private final int SIZE;
	private int top;
	
	public StackImpUsingArray(int size) {
		this.SIZE=size;
		top=-1;
		
	}
	
	
	public void push(int element){
		if(top>=SIZE)
			return ;
		else
			x[top++]=element;
	}
	
	
	public int pop(){
		if(top==-1)
			return -99;
		else
			return x[top--];
	}
}




When to Use Interface vs Abstract Class in Java
--------------------------------------------------

When to Use an Interface
---------------------------
	Use interface to define a contract that unrelated classes can implement.
	Best when you want to break inheritance hierarchy.
	Supports multiple inheritance of types.
	Ideal for capability-based design (e.g., Flyable, Drivable, Cloneable).



Key Points:
----------------------------------------------
Feature					Interface
----------------------------------------------
Purpose				Define capability/contract

Inheritance			Multiple interfaces allowed

State (fields)		Constants only (public static final)

Access modifiers	All methods are public abstract by default (Java 8+ allows default/static methods)

Use case			Unrelated classes with common behavior



When to Use an Abstract Class
-----------------------------
	Use abstract class when you want to provide a base class with shared code.
	Ideal when classes are closely related.
	You can define common fields, constructors, and method implementations.

Key Points:
------------------------------------------
Feature						Abstract Class
------------------------------------------
Purpose						Code reuse with partial implementation
Inheritance					Single inheritance only
State (fields)				Yes, allowed
Constructors				Yes, allowed
Use case					Hierarchical design (base -> derived classes)




Analogy Example – Breaking Hierarchy
-------------------------------------------
		Let’s say we have two unrelated classes: Top (a toy) and Tyre (a vehicle part). 
		Both can rotate but don’t share a common base.
		
		
Problem with Abstract Class:
-----------------------------
	You can’t extend both Toy and VehiclePart — Java doesn’t allow multiple inheritance.



Solution with Interface:
-------------------------
public interface Rotatable {
    void rotate();
}

Concrete Classes
------------------
public class Top implements Rotatable {
    @Override
    public void rotate() {
        System.out.println("Kids spin the top and enjoy...");
    }
}

public class Tyre implements Rotatable {
    @Override
    public void rotate() {
        System.out.println("Tyre rotates and moves the vehicle...");
    }
}



Client Code
---------------
public class InterfaceDemo {
    public static void main(String[] args) {
        Rotatable top = new Top();
        Rotatable tyre = new Tyre();

        top.rotate();
        tyre.rotate();
    }
}


Summary Table
-------------------------------------------------
Scenario							Prefer
--------------------------------------------------------------------
You want to share code between related classes				Abstract Class
You need multiple inheritance								Interface
You only want to define behavior/capability contract		Interface
You want default implementation + flexibility				Abstract Class
Your design models “is-a” relationship						Abstract Class
Your design models “can-do” relationship					Interface



Rule of Thumb
------------------
	Interface = "can do" (e.g., Runnable, Comparable)
	Abstract class = "is a type of" (e.g., Animal, Shape)




=> interface improve oo design
------------------------------

class Bird{
	void sound(){
		System.out.println("bird sound");
	}
	void swimm(){
		System.out.println("default swimming.....");
	}
	void fly(){
		System.out.println("Default flying....");
	}
}

class Eagle extends Bird{
	
}

class Emu extends Bird{
	
}

class Duck extends Bird{
	
}





composition, aggrigation, inheritance
--------------------------------------
relationship bw the objects:-

IS-A
HAS-A
USE-A

FAVOUR COMPOSITION OVER INHERITANCE? WHAT ITS MEAN?


loose coupling and high cohesion,design as per interface
-------------------------------------------------

	Simple case study!

	"A passanger is using metro to travel from Laxmi Nagar to Noida"




class Metro{
	public void move(String source, String desination){
		System.out.println("moving from " + source+ " to " + desination);
	}
}

class Passanger{
	private String passangerName;
	public Passanger(String passangerName) {
		this.passangerName = passangerName;
	}


	public void travel(Metro metro,String source, String desination ){
		System.out.println("Passanger name: "+ passangerName);
		metro.move(source, desination);
	}
}
public class Demo {
	public static void main(String[] args) {
		
		Metro metro=new Metro();
		Passanger passanger=new Passanger("amit");
		passanger.travel(metro, "Laxmi nagar", "noida");
	}

}


favour composition over inheritance
-----------------------------------
	=> square rectangle liskov java

class Rectangle{
	private int l, b;

	public int getL() {
		return l;
	}

	public void setL(int l) {
		this.l = l;
	}

	public int getB() {
		return b;
	}

	public void setB(int b) {
		this.b = b;
	}

	public Rectangle(int l, int b) {
		this.l = l;
		this.b = b;
	}
	
	public int calculateArea(){
		return l*b;
	}
	
}

class Square extends Rectangle{
	public Square(int l){
		super(l, l);
	}
}


What and Why design pattern
-------------------------

	=> tried and tested solutions to work with

	=> language neutral and so can be applied to any OO language

	=>proven track record as they are already widely used and thus reduce 
	the technical risk to the project

	=>highly flexible and can be used in practically 
		any type of application or domain










Design Principles (SOLID)
---------------------------

    Single Responsibility Principle
	Open Close Principle
	Liskov's Substitution Principle
	Dependency Inversion Principle
	Interface Segregation Principle
	


Understanding SRP
-------------------
class Book {
	private int id;
	private String isbn;
	private String title;
	private String author;
	private double price;
	
	public Connection  getConnection(){
		// code to get jdbc connection..
		return null;
	}

	public SessionFactory  getFactory(){
		// code to get jdbc connection..
		return null;
	}
	public void addBook(Book book)throws SQLException{
		System.out.println("adding book to db using jdbc..");
	}
       public void addBookUsingHibernate(Book book)throws HibernateException{
		System.out.println("adding book to db using hibernate....");
	}
}






public interface BookDao {
		public List<Book> getAllBooks();
		public Book getBookById(int bookId);
		public void addBook(Book book);
		public void updateBook(Book book);
		public void removeBook(int bookId);
}






mysql -u root -p
use  d_jug;

create table Book (id integer not null auto_increment, author varchar(255), isbn varchar(255), price double precision not null, title varchar(255), primary key (id));

insert into Book (author, isbn, price, title) values ('raj', 'abc121', 4455.8, 'java head first');



con=DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/d_jug","root","root");
			stmt=con.prepareStatement("insert into Book (author, isbn, price, title) values (?, ?, ?, ?)");
			stmt.setInt(1, "raja");
			stmt.setString(2, "abc121");
			stmt.setDouble(3, 3333.6);
			stmt.setString(2, "java head first");
			stmt.executeUpdate();




db.properties
-------------------
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/UserDB
user=root
password=root



Create an connection factory
-------------------------


package com.daniel.util;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class DbUtil {

    private static Connection connection = null;

    public static Connection getConnection() {
        if (connection != null)
            return connection;
        else {
            try {
                Properties prop = new Properties();

                InputStream inputStream = DbUtil.class.getClassLoader().getResourceAsStream("db.properties");

                prop.load(inputStream);
                String driver = prop.getProperty("driver");
                String url = prop.getProperty("url");
                String user = prop.getProperty("user");
                String password = prop.getProperty("password");
                Class.forName(driver);
                connection = DriverManager.getConnection(url, user, password);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return connection;
        }

    }
}



GOF Pattern categories
---------------------------------
  ==> GOF, 23 patterns
   ==> Classification patterns: 

	Creational
	Structural
	Behavioral



Creational Pattern
-------------------

	==> What is the best way to create object?

	==> Creational Pattern
		=> Singleton
		=> Factory
		=> Abstract Factory
		=> Builder
		=> Prototype

structural patterns 
--------------------

	==> Structural Patterns describe how objects and 
		classes can be combined to form larger structures

	==> class patterns vs object patterns

	==> The difference between class patterns and object patterns is that 
		class patterns describe abstraction with the help of inheritance
		and how it can be used to provide more useful program interface. 

	==> Object patterns, on other hand, describe how objects can
		 be associated and composed to form larger, more complex structures

	
	==> structural patterns 

		=> Adapter Pattern
		=> Decorator Pattern :io
		=> Facade Pattern 
		=> Proxy Pattern



Behavioral Patterns
------------------

	==> Behavioural patterns are those which are concerned with 
		interactions between the objects.

	==> The interactions between the objects should be such that they 
	  are talking to each other and still are loosely coupled. 


	==> The loose coupling is the key to n-tier architectures. 
		In this, the implementation and the client should be loosely 
		coupled in order to avoid hard-coding and dependencies.

	==> Behavioral Patterns
		=> Strategy Pattern
		=> Chain of Responsibility Pattern
		=> Iterator Pattern
		=> Observer Pattern 
		=> Template Pattern






	Singleton Pattern
	===================

	" one object per application" ex logging , db connection etc

	=> lazy vs eager
	=> threading issue, double locking
	=> What if clonned
	=> What if deserilized?
	=> What if used java reflection?
	=> what if 2 class loader load that class twice
	=> best practices, effective java
	=> using enum

	Attempt 1:

	class SingletonObject {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

	}

	Attempt 2: What about race condition?

	
	class SingletonObject  {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static synchronized SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

	}

	Attempt 3: What if somebody make clone of Singleton object?

	
	class SingletonObject  implements Cloneable {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static synchronized SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

		public Object clone() throws CloneNotSupportedException {
			throw new CloneNotSupportedException();
		}

	}



	Attempt 4: Double locking
		This optimization consist in checking in an unsynchronized block if
		 the object is null and if not to check again and create it in an syncronized block. 
		This is called double locking mechanism
	
	class SingletonObject  implements Cloneable {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static  SingletonObject getSingletonObject() {

			if (singletonObject == null){
			synchronized(SingletonObject.class)
			{
				if (singletonObject== null)
				{
					System.out.println("getInstance(): First time getInstance was invoked!");
					instance = new Singleton();
				}
			}            
		}

		return singletonObject;


		}

		public Object clone() throws CloneNotSupportedException {
			throw new CloneNotSupportedException();
		}

	}

	What if used reflection to create an object:
	--------------------------------------------
		Constructor[] constructors=SingletonObject.class.getDeclaredConstructors();
		constructors[0].setAccessible(true);
		SingletonObject s2=(SingletonObject) constructors[0].newInstance();


	What if serialization is done?

	protected Object readResolve() {
   		 return getInstance();
	}



	Prototype Pattern (best practics for creating clone)
	===================================================
https://www.youtube.com/watch?v=9DD4RnHxHCE&list=PLv2-IhRmhbyQK19NcFRRJbK9Xf2YX_BgW&index=7&ab_channel=BusyCoderAcademy
		=> About creating clone of an object

		=> Why clonning? cloning of an object to avoid creation

		=> If the cost of creating a new object is large and creation 
			is resource intensive, we clone the object

		=> We use the interface Cloneable and call its method clone() to clone the 			
			object

		=> Deep copy vs shallow copy

		=> Shallow copying generally means copying only one level of an object,
		 while deep copying generally means copying more than one level


	Ex:

	
//about what is the best practice to create clone of an object?

  class Employee implements Cloneable {
	private Integer id;
	private String name;
	private Date hireDay;//mutable

	public Employee(Integer id, String name, Date date) {
		super();
		this.id = id;
		this.name = name;
		this.hireDay=date;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", hireDay=" + hireDay
				+ "]";
	}

	@Override
	public Object clone() throws CloneNotSupportedException {
		 // call Object.clone()
		 Employee cloned = (Employee) super.clone();

		// clone mutable fields
		 cloned.hireDay = (Date) hireDay.clone();

		 return cloned;
	}

	public void changeHireDay(int year, int month, int day){
		 hireDay.setDate(day);
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getHireDay() {
		return hireDay;
	}

	public void setHireDay(Date hireDay) {
		this.hireDay = hireDay;
	}
	
	
}

public class Demo {
	public static void main(String[] args) throws CloneNotSupportedException {
			Date date=new GregorianCalendar(2001, 11, 22).getTime();
		
		Employee employee1 = new Employee(33, "raja", date);
	
		Employee employee2 = (Employee) employee1.clone();
	
		System.out.println(employee1);
		System.out.println(employee2);
		
		System.out.println("After changing............");
		employee1.changeHireDay(2011, 11, 11);
		employee1.setName("amit");
		System.out.println(employee1);
		System.out.println(employee2);

	}

}


Builder Pattern
================

	==> The Builder pattern can be used to ease the construction 
	   of a complex object from simple objects

	public class Food {
		private String name;
		private int unit;
		private int vitC;
		private int vitA;
		private int vitB12;
		private int vitB5;
		private int vitD;

		//
		
	}
		
	// FoodBuilder.java
	public class FoodBuilder {

		private String name;
		private int unit;
		private int vitC = 100;
		private int vitA = 100;
		private int vitB12 = 100;
		private int vitB5 = 100;
		private int vitD = 5000;

		public FoodBuilder(String name, int unit) {
			this.name = name;
			this.unit = unit;
		}

		public FoodBuilder setVitC(int vitC) {
			this.vitC = vitC;
			return this;
		}

		public FoodBuilder setVitA(int vitA) {
			this.vitA = vitA;
			return this;
		}

		public FoodBuilder setVitB12(int vitB12) {
			this.vitB12 = vitB12;
			return this;
		}

		public FoodBuilder setVitB5(int vitB5) {
			this.vitB5 = vitB5;
			return this;
		}

		public FoodBuilder setVitD(int vitD) {
			this.vitD = vitD;
			return this;
		}

		public FoodBuilder setName(String name) {
			this.name = name;
			return this;
		}

		public Food build() {
			return new Food(name, unit, vitC, vitA, vitB12, vitB5, vitD);
		}
	}


	public class DemoBuilder {
	
		public static void main(String[] args) {
			Food food=new FoodBuilder("apple", 400).setVitA(5000).build();
		}
	}

	
	Factory Method
	===============
	Defind an interface for creating an object, but let subclass decide which object to instantiate, 
		Factory method let a class defer instantiation to subclass using inheritance

	=> provide an interface for creating an oblject here do not consider the word interface as java interface. 
	It simply mean to provides a contract / method to create an object

	=> let the subclass decide what exact object ot instantiate- This pattern involve "inheritance"


	=>Calendar calendar = Calendar.getInstance();
		System.out.println(calendar);

	=> createStatement() of java.sql.Connection interface

	=> createSocket() of java.rmi.server.RmiClientSocketFactory



db.properties
-------------------

driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/bookapp
user=root
password=root




Create an connection factory
-------------------------


import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class ConnectionFactory{

    private static Connection connection = null;

    public static Connection getConnection() {
        if (connection != null)
            return connection;
        else {
            try {
                Properties prop = new Properties();
		//FileInputStream in = new FileInputStream
                InputStream inputStream = ConnectionFactory.class.getClassLoader().getResourceAsStream("db.properties");

                prop.load(inputStream);
                String driver = prop.getProperty("driver");
                String url = prop.getProperty("url");
                String user = prop.getProperty("user");
                String password = prop.getProperty("password");
                Class.forName(driver);
                connection = DriverManager.getConnection(url, user, password);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return connection;
        }

    }
}




	Factory Method pattern
	========================
	https://www.youtube.com/watch?v=EdIwFK0gCm4&ab_channel=Ranjithramachandran
	=> Defind an interface for creating an object, but let subclass decide which object to instantiate, 
		Factory method let a class defer instantiation to subclass using inheritance.

	Implementation:
	---------------
	=> provide an interface for creating an oblject here do not consider the word interface as java interface. 
	It simply mean to provides a contract / method to create an object

	=> let the subclass decide what exact object ot instantiate- This pattern involve "inheritance"

	=> let we write an batch file processor
	 steps: 1. open an file
		2. choose a parser
		3. use parser to get List of records
		4. process record ie put to db
		5. write summery
		6. close file


		File f=openFile(fileName);
		

	Attempt 1: Writing batch process for processing text file
	---------------------------------------------------------
	
	public class BatchProcessor {
	
		public void processBatch(String fileName) {
			File file = openFile();
			TextParser parser = new TextParser(file);
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}
	
		private void processorRecords(List<Record> records) {
			System.out.println("processing each record to db");
		}
	
		private void writeSummray() {
			System.out.println("writing summery report");
		}
	
		private void closeFile() {
			System.out.println("closing the file...");
		}
	
		private File openFile() {
			System.out.println("open the file...");
			return null;
		}
	}


	public class TextParser {
	
		public TextParser(File file) {
			System.out.println("creating text parser...");
		}
	
		public List<Record> parse() {
			System.out.println("creating record list using text parser...");
			return null;
		}
	
	}


	public class Record {}


	public class Main {
		public static void main(String[] args) {
			
			BatchProcessor batchProcessor=new BatchProcessor();
			batchProcessor.processBatch("foo");		
		}
	}


	Attempt 2: Writing batch process for processing cvs file too...
	---------------------------------------------------------
	
	To cater the requirment i will create an interface:
	
	public interface Parser {
		public abstract List<Record> parse();
	}


	public class CVSParser implements Parser {
		public CVSParser(File file) {
			System.out.println("creating cvs parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using cvs parser...");
			return null;
		}
	
	}


	public class TextParser implements Parser {
		public TextParser(File file) {
			System.out.println("creating text parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using text parser...");
			return null;
		}
	}


	Now  i need to change BatchProcessor class and need to pass choice of parser: 


	public void processBatch(String fileName, String format) {
		Parser parser=null;
		File file = openFile();
		if(format.equals("text"))
			parser = new TextParser(file);
		else if(format.equals("cvs"))
			parser=new CVSParser(file);
			
		List<Record> records = parser.parse();
		processorRecords(records);
		writeSummray();
		closeFile();

	}


	Attempt 3: Writing batch process for processing xml file too...
	---------------------------------------------------------
		public class XmlParser implements Parser {
		
		public XmlParser(File file) {
			System.out.println("creating xml parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using xml parser...");
			return null;
		}
	
	}



	Now again i need to change BatchProcessor class and need to pass choice of parser: 


			public void processBatch(String fileName, String formete) {
			Parser parser=null;
			File file = openFile();
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
				
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}


	=> clear voilation of OCP
	=> We are supposed to change BatchProcessor every now and then, can not do in case of api design 
	=> voilation of Dependency inversion: depend on abstraction

	Solution:
	---------
		=> this is not acceptable code:
		   ----------------------------
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
			else if(formete.equals("xml"))
				parser=new XmlParser(file);



		=> refactoring code:
		--------------------

public class BatchProcessor {

	public void processBatch(String fileName, String formete) {
		Parser parser = null;
		File file = openFile();

		parser = createParser(file);
		List<Record> records = parser.parse();
		processorRecords(records);
		writeSummray();
		closeFile();

	}
	 abstract Parser createParser(File file);

}

		=> now its works as a framework for batch processing
		and we never have to change BatchProcessor for changing parser approach


	
	BatchProcessor batchProcessor=new TextBatchProcessor();
	batchProcessor.processBatch("foo","xml");
			
	https://stackoverflow.com/questions/13029261/
	design-patterns-factory-vs-factory-method-vs-abstract-factory/35851402#35851402






structural patterns 
==========================
		=> Adapter
		=> Decorator
		=> Facade Pattern
		=> Bridge
		=> Composite
		=> Flyweight
		=> Proxy

Adapter Pattern
================
	==> It helps in integrating two modules with different incompatible interfaces. 
	==> The Adapter pattern is used so that two unrelated interfaces can work together
	==> The joining between them is called an Adapter. 
	==> This is something like we convert interface of one class into interface expected by the client. 
	==>  Way to implement adaper
		=> Using inheritance: A class adapter 
		=> User composition: An object adapter

	Use cases:
	----------
	1. Most important task of an Adapter is to transfer data between applications or modules.
	2. Very common task is to parse the information from one kind to the other
	3. Convert from one type to the other
	4. Some times adapters even validate the data so that right data flows into the application 
	from external applications.

	=> Having adapters help in keeping the conversion code separate so that the parsing functionality
	 is not leaking into the core modules of our application.

	=> Another important advantage of having an adapter is that when there is a 
	change in outside interface, our core modules does not get affected. 
	Only adapters need to be modified. So, this helps in restricting the changes to 
	 adapter module alone and rest of application does not get affected. 




	Convert the interface of a class into another interface clients expect. 
	Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.


	Adapter Pattern hello world:
	----------------------------
	public class RoundPeg {
		public void insertTohole(String str) {
			System.out.println("roundpeg insertTohole(): " + str);
		}
	}

	public class SquarePeg {
		public void insert(String str) {
			System.out.println("SquarePeg insert(): " + str);
		}
	}



	// adaptoing roundpeg to square pag
	public class PegAdaptor extends SquarePeg  {
	
		private RoundPeg peg;
	
		public PegAdaptor(RoundPeg peg) {
			super();
			this.peg = peg;
		}
		
		public void insert(String str) {
			peg.insertTohole(str);
		}
	}



//adaptoing roundpeg to square pag
public class Demo {

	public static void main(String[] args) {
		
		RoundPeg peg=new RoundPeg();
		PegAdaptor adpt=new PegAdaptor(peg);
		adpt.insert("hello");
	}
}

Examples:
---------
java.util.Arrays#asList()
java.io.InputStreamReader(InputStream) (returns a Reader)
java.io.OutputStreamWriter(OutputStream) (returns a Writer)




decorator pattern / wrapper pattern 
=================================

	=> Decorator pattern helpful in adding behaviour to objects statically or dynamically.

	=> Decorator pattern helps in extending the functionality of the objects without
	 effecting the behaviour of other objects.

	=> Decorator adhering to the design principle of Open for extension and closed for modification

	=> In the Decorator pattern, a decorator object is wrapped around the original object

 	=> This is typically achieved having the original object as a member
		 of the decorator, with the decorator forwarding the 
		requests to the original object and also implementing the new functionality

	==> The decorator must conform to the interface of the original object
		 (the object being decorated) 


	=> Simple greet application:
	---------------------------------

	Car-> BasicCar-> SportCar->SuperSportCar
		
	
	interface Car{
		public String assemble();
	}
	class BasicCar implements Car{
	
		@Override
		public String assemble() {
			return "basic car";
		}
		
	}
	abstract class CarDecorator implements Car{
		private Car car;
		public CarDecorator(Car car) {
			this.car = car;
		}
		
		@Override
		public String assemble() {
			return car.assemble();
		}
	}
	class SportCar extends CarDecorator{
	
		public SportCar(Car car) {
			super(car);
		}
	
		@Override
		public String assemble() {
			return super.assemble()+" with sport feature";
		}
	}
	
	class SuperSportCar extends CarDecorator{
	
		public SuperSportCar(Car car) {
			super(car);
		}
	
		@Override
		public String assemble() {
			return super.assemble()+" with extra super sport feature";
		}
	}



SuperSportCar sportCar=new SuperSportCar(new SportCar(new BasicCar()));

proxy design pattern:
------------------
	=> Provide a surrogate or placeholder for another object to control access to it

	public class Magician {
	
		public void doMagic(){
			System.out.println("abra ka dabra...");
		}
	}


	public class AudianceAdvice {
	
		public void clapping(){
			System.out.println("maza aa gaya...");
		}
	}



	@Aspect
	@Component
	public class AudianceAdvice {
		@Before("execution(public void doMagic())")
		public void clapping(){
			System.out.println("maza aa gaya...");
		}
	}


Example RMI:
=============



RMI server
-------------

public interface AtmCard extends Remote {

	public boolean isValid(String card)throws RemoteException;
}





public class AtomCardImp extends UnicastRemoteObject implements AtmCard,
		Serializable {

	protected AtomCardImp() throws RemoteException {
		super();
	}

	@Override
	public boolean isValid(String card) throws RemoteException {
		Integer val = Integer.parseInt(card);
		if (val % 2 == 0)
			return false;
		else
			return true;
	}

}



public class Server {
	public static void main(String[] args) throws RemoteException, AlreadyBoundException {
		AtomCardImp obj=new AtomCardImp();
		
		Registry registry=LocateRegistry.createRegistry(222);//pass port no
		registry.bind("obj", obj);
		System.out.println("service is bound!");
		
	}

}



RMI Client
-------------


public interface AtmCard extends Remote {

	public boolean isValid(String card)throws RemoteException;
}



public class RMIClient {
	public static void main(String[] args) throws RemoteException, NotBoundException {
		Registry registry=LocateRegistry.getRegistry("localhost", 222);
		AtmCard card=(AtmCard) registry.lookup("obj");
		
		System.out.println(card.isValid("121"));
		
	}

}



	 


======================
 Behavioral Patterns
======================

		Iterator
		Observer
		Strategy
		Chain of Responsibility
		Template design pattern
		Command
		Interpreter
		Mediator
		Memento
		


	Iterator design pattern:
	------------------------
	=> iterator pattern allows for the traversal through the elements
	 in a grouping of objects via a standardized interface. 

	=> An Iterator interface defines the actions that can be performed.

	=>  These actions include being able to traverse the objects and also obtain the objects


	Example : write our own iterator by implementing java.util.Iterator
		 hasNext(), next(), and remove() methods



public class Item {

	String name;
	float price;

	public Item(String name, float price) {
		this.name = name;
		this.price = price;
	}

	public String toString() {
		return name + ": $" + price;
	}
}



public class Menu {

	List<Item> menuItems;

	public Menu() {
		menuItems = new ArrayList<Item>();
	}

	public void addItem(Item item) {
		menuItems.add(item);
	}

	public Iterator<Item> iterator() {
		return new MenuIterator();
	}

	class MenuIterator implements Iterator<Item> {
		int currentIndex = 0;

		@Override
		public boolean hasNext() {
			if (currentIndex >= menuItems.size()) {
				return false;
			} else {
				return true;
			}
		}

		@Override
		public Item next() {
			return menuItems.get(currentIndex++);
		}

		@Override
		public void remove() {
			menuItems.remove(--currentIndex);
		}

	}

}


public class Demo {

	public static void main(String[] args) {

		Item i1 = new Item("mouse", 7.50f);
		Item i2 = new Item("laptop", 6.00f);
		Item i3 = new Item("DVD", 6.50f);

		Menu menu = new Menu();
		menu.addItem(i1);
		menu.addItem(i2);
		menu.addItem(i3);

		System.out.println("Displaying Menu:");
		Iterator<Item> iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

		System.out.println("\nRemoving last item returned");
		iterator.remove();

		System.out.println("\nDisplaying Menu:");
		iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

	}

}


Observer design pattern:
========================

	=> Observer pattern in java is one of the most important design patterns. 
	=> The concept behind the Observer design pattern is the basis for PubSub, event and non blocking based systems
	
	

		//observable (news paper wala)
		public class MySubject extends Observable {
			private String name;
			private float price;
		
			public MySubject(String name, float price) {
				this.name = name;
				this.price = price;
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			public float getPrice() {
				return price;
			}
		
			public void setPrice(float price) {
				this.price = price;
				setChanged();
				notifyObservers(new Float(price));
			}
		
		}
		
		


			
			public class MyObserver  implements Observer{
				private float price;
				
				@Override
				public void update(Observable o, Object a) {
					
					price=(float) a;
					
					System.out.println("price observed : price changed to :"+price);
				}
			
			}





		MySubject subject=new MySubject("rice", 55);
		MyObserver o=new MyObserver();
		
		subject.addObserver(o);
		
		subject.setPrice(88);
		subject.setPrice(99);


 Why Not Use Observable and Observer?
 ---------------------------------
Deprecated Since Java 9
	Both Observable and Observer are legacy, and Observable is a concrete class, 
	violating the program-to-interface principle.

	You can't extend another class if you extend Observable (Java supports only single inheritance).

	Tight Coupling
		You are forced to extend Observable, which leads to tight coupling.
		Observer interface receives updates as a raw Object, which is error-prone and lacks type safety.


Modern Alternative: Use Custom Observer Pattern via Interfaces
----------------------------------------------------------------
Modern Implementation
-----------------------------------
Subject Interface (Observable)
------------------------
import java.util.ArrayList;
import java.util.List;

public interface Subject {
    void addObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}


Observer Interface
-------------------------
public interface Observer {
    void update(float newPrice);
}


Concrete Subject: Product
----------------------------
public class Product implements Subject {
    private String name;
    private float price;
    private List<Observer> observers = new ArrayList<>();

    public Product(String name, float price) {
        this.name = name;
        this.price = price;
    }

    public void setPrice(float price) {
        this.price = price;
        notifyObservers();
    }

    public float getPrice() {
        return price;
    }

    @Override
    public void addObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(price);
        }
    }
}


Concrete Observer: Customer
---------------------------------
public class Customer implements Observer {
    private String name;

    public Customer(String name) {
        this.name = name;
    }

    @Override
    public void update(float newPrice) {
        System.out.println(name + " observed new price: ₹" + newPrice);
    }
}


Demo Application
--------------------
public class ObserverDemo {
    public static void main(String[] args) {
        Product rice = new Product("Rice", 55);

        Observer customer1 = new Customer("Rajeev");
        Observer customer2 = new Customer("Anita");

        rice.addObserver(customer1);
        rice.addObserver(customer2);

        rice.setPrice(88);
        rice.setPrice(99);
    }
}


Real-World Applications of Observer Pattern
------------------------------------------
Application							Use Case
------------------------------------------------
GUI Frameworks						UI components react to state changes
Event Systems						Publish/subscribe systems (e.g. Kafka, EventBus)
MVC									View observes the Model
Stock Tickers						Price updates sent to clients
Notification 						System	Send alerts on state changes


Note: 
--------------
RxJS implements the Observer Pattern using Observable and subscribe().
Observer pattern in RxJS is reactive and asynchronous.
Observer has next(), error(), and complete() methods.
You can use built-in operators (map, filter, take, mergeMap, etc.) to transform streams.








Chain of Responsibility
-----------------------

	=> used to achieve loose coupling in software design where a request 
	from client is passed to a chain of objects to process them. 

	=>Then the object in the chain will decide themselves who will 
	be processing the request and whether the request is 
	required to be sent to the next object in the chain or not.

	=> ex:  try-catch block

	=> Ex: ATM Dispense machine, 50$, 20$, 10$ etc




public class Currency {

	private int amount;
	
	public Currency(int amt){
		this.amount=amt;
	}
	
	public int getAmount(){
		return this.amount;
	}
}



public interface DispenseChain {

	void setNextChain(DispenseChain nextChain);
	
	void dispense(Currency cur);
}




public class Dollar50Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 50){
			int num = cur.getAmount()/50;
			int remainder = cur.getAmount() % 50;
			System.out.println("Dispensing "+num+" 50$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}





public class Dollar20Dispenser implements DispenseChain{

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 20){
			int num = cur.getAmount()/20;
			int remainder = cur.getAmount() % 20;
			System.out.println("Dispensing "+num+" 20$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}




public class Dollar10Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 10){
			int num = cur.getAmount()/10;
			int remainder = cur.getAmount() % 10;
			System.out.println("Dispensing "+num+" 10$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}



//  Creating the Chain
======================
public class ATMDispenseChain {

	private DispenseChain c1;

	public ATMDispenseChain() {
		// initialize the chain
		this.c1 = new Dollar50Dispenser();
		DispenseChain c2 = new Dollar20Dispenser();
		DispenseChain c3 = new Dollar10Dispenser();

		// set the chain of responsibility
		c1.setNextChain(c2);
		c2.setNextChain(c3);
	}

	public static void main(String[] args) {
		ATMDispenseChain atmDispenser = new ATMDispenseChain();
		while (true) {
			int amount = 0;
			System.out.println("Enter amount to dispense");
			Scanner input = new Scanner(System.in);
			amount = input.nextInt();
			if (amount % 10 != 0) {
				System.out.println("Amount should be in multiple of 10s.");
				return;
			}
			// process the request
			atmDispenser.c1.dispense(new Currency(amount));
		}

	}

}


template design pattern:
-------------------------
http://www.journaldev.com/1763/template-method-design-pattern-in-java


	=> Template Method is a behavioral design pattern. 

	=> Template Method design pattern is used to create a method stub and 		
		deferring some of the steps of implementation to the subclasses.

	=> Template method defines the steps to execute an algorithm and it
	 can provide default implementation that might be common for all or some of 		
		the subclasses.

	=> suppose we want to provide an algorithm to build a house. 
	The steps need to be performed to build a house are 
	 building foundation, building pillars, building walls and windows.

	=>  The important point is that the we cant change the order of execution
	 because we can't build windows before building the foundation.

	=> So in this case we can create a template method that will use different methods to build the house



public abstract class HouseTemplate {

	//template method, final so subclasses can't override
	public final void buildHouse(){
		buildFoundation();
		buildPillars();
		buildWalls();
		buildWindows();
		System.out.println("House is built.");
	}

	//default implementation
	private void buildWindows() {
		System.out.println("Building Glass Windows");
	}

	//methods to be implemented by subclasses
	public abstract void buildWalls();
	public abstract void buildPillars();

	private void buildFoundation() {
		System.out.println("Building foundation with cement,iron rods and sand");
	}
}



public class WoodenHouse extends HouseTemplate {

	@Override
	public void buildWalls() {
		System.out.println("Building Wooden Walls");
	}

	@Override
	public void buildPillars() {
		System.out.println("Building Pillars with Wood coating");
	}

}




public class GlassHouse extends HouseTemplate {

	@Override
	public void buildWalls() {
		System.out.println("Building Glass Walls");
	}

	@Override
	public void buildPillars() {
		System.out.println("Building Pillars with glass coating");
	}

}



		HouseTemplate houseType = new WoodenHouse();
		
		//using template method
		houseType.buildHouse();
		System.out.println("************");
		
		houseType = new GlassHouse();
		
		houseType.buildHouse();



	Example in jdk:
	-----------------
	=> All non-abstract methods of java.io.InputStream, java.io.OutputStream, java.io.Reader and java.io.Writer.

	=> All non-abstract methods of java.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap.




Strategy Pattern 
================
	=>The strategy pattern is intended to provide a means to define a family of algorithms, encapsulate each one '
	as an object, and make them interchangeable select algo at run time convert IS-A to HAS-A



Strategy Pattern 
================
https://softwareengineering.stackexchange.com/questions/347505/how-to-design-the-classes-for-a-simple-shopping-cart-example-using-strategy-desi

Strategy Pattern
-----------------
	=>The strategy pattern is intended to provide a means to define a family of algorithms,    		
	encapsulate each one as an object, and make them interchangeable select algo at run time 		
	convert IS-A to HAS-A

	=> It separate algorithms into classes that can be plugged in at runtime.
 
	=> I need to provide discount strategy for code flexibility 

	=> used when we have multiple algorithm for a specific task and client
	 decides the actual implementation to be used at runtime.



Designing shopping cart :
------------------------

Strategy Pattern – Shopping Cart Example in Java
-------------------------------------------------
Strategy Pattern Recap
-----------------------------
	Purpose: Define a family of algorithms, encapsulate each one, and make them interchangeable.
	Benefit: Client can choose an algorithm at runtime without modifying the context.
	Real-life Use Case: Shopping cart with flexible discount strategies


Product Class
--------------
public class Product {
    private int id;
    private String name;
    private double price;
    private int quantity;

    public Product(int id, String name, double price, int quantity) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.quantity = quantity;
    }

    // Getters and Setters
    
}


Discount Strategy Interface
-------------------------------
public interface Discount {
    void apply(Product product);
}



Concrete Strategy 1: Buy X Get Y Items Free
-------------------------------------------------
public class BuyXGetYItemFree implements Discount {
    private int x;
    private int y;

    public BuyXGetYItemFree(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public void apply(Product product) {
        if (product.getQuantity() >= x) {
            int freeItems = (product.getQuantity() / x) * y;
            product.setQuantity(product.getQuantity() + freeItems);
        }
    }
}



Concrete Strategy 2: Buy X Get Y% Discount
-----------------------------------------
public class BuyXGetYPercentageDiscount implements Discount {
    private int x;
    private int percentage;

    public BuyXGetYPercentageDiscount(int x, int percentage) {
        this.x = x;
        this.percentage = percentage;
    }

    @Override
    public void apply(Product product) {
        if (product.getQuantity() >= x) {
            double discountedPrice = product.getPrice() * (1 - percentage / 100.0);
            product.setPrice(discountedPrice);
        }
    }
}




Cart Class (Context)
-----------------------
import java.util.ArrayList;
import java.util.List;

public class Cart {
    private List<Product> productList = new ArrayList<>();
    private Discount discountStrategy;

    public void setDiscount(Discount discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    public void addProduct(Product product) {
        if (discountStrategy != null) {
            discountStrategy.apply(product);
        }
        productList.add(product);
    }

    public int getProductCount() {
        return productList.size();
    }

    public double getTotalCartValue() {
        double total = 0;
        for (Product p : productList) {
            total += p.getPrice() * p.getQuantity();
        }
        return total;
    }
}





Demo / Client Code
----------------------
public class StrategyPatternDemo {
    public static void main(String[] args) {
        Product p1 = new Product(101, "Milk", 20, 5);
        Product p2 = new Product(102, "Soap", 10, 10);

        Cart cart = new Cart();

        // Strategy: Buy 5 get 2 free
        cart.setDiscount(new BuyXGetYItemFree(5, 2));
        cart.addProduct(p1);

        // Strategy: Buy 10 get 20% off
        cart.setDiscount(new BuyXGetYPercentageDiscount(10, 20));
        cart.addProduct(p2);

        System.out.println("Total Products: " + cart.getProductCount());
        System.out.println("Total Cart Value: ₹" + cart.getTotalCartValue());
    }
}



Concept					Details
---------------------------------------------------------
Context					Cart uses a Discount strategy
Strategy Interface		iscount
Concrete Strategies		BuyXGetYItemFree, BuyXGetYPercentageDiscount
Flexibility	Discount 	logic can be swapped without changing Cart
Extensible				Add new strategies easily (e.g., FestivalDiscount, BulkPurchaseDiscount)









command design pattern:
=======================

Command Design Pattern
-----------------------

Intent:
-------
	Encapsulate a request as an object, thereby allowing for:
	parameterization of clients with queues, requests, and logs
	undoable operations
	
	

Real-Life Analogy: Remote Control
-----------------------------------

       +----------------+
       |   Remote       |  (Invoker)
       +----------------+
             |
         pressButton()
             |
             v
      +--------------+
      | Command      | <-----+
      +--------------+       |
             |               |
     +-------+------+        |
     |              |        |
LightOnCommand   LightOffCommand (Concrete Commands)
     |              |
     v              v
 +----------------------+
 |      Light           | (Receiver)
 +----------------------+



Without Command Pattern — Tight Coupling Example
-------------------------------------------------------
Imagine you’re designing a Remote Control for a light.


public class Light {
    public void turnOn() {
        System.out.println("Light is ON");
    }

    public void turnOff() {
        System.out.println("Light is OFF");
    }
}

public class RemoteControl {
    private Light light = new Light();

    public void pressOnButton() {
        light.turnOn();
    }

    public void pressOffButton() {
        light.turnOff();
    }
}

Problems:
-----------
	RemoteControl is tightly coupled to Light.
	If you want to control a Fan or TV, you need to change RemoteControl code.
	Violates Open/Closed Principle (open for extension, closed for modification).


With Command Pattern — Decoupled, Flexible
-------------------------------------------
Goal:
	Convert actions into Command objects.
	Remote control doesn’t know what it's controlling — just executes a command.


ASCII Diagram of Command Pattern
--------------------------------

+---------------------+        +-----------------+
|     RemoteControl   | -----> |   Command       |
|  (Invoker)          |        |  (Interface)    |
+---------------------+        +-----------------+
          |                            ^
          |                            |
          v                            |
+---------------------+      +------------------------+
|     LightOnCommand  |      |     LightOffCommand    |
|  (ConcreteCommand)  |      |   (ConcreteCommand)     |
+---------------------+      +------------------------+
          |                            |
          v                            v
+---------------------------------------------+
|                Light                        |
|            (Receiver)                       |
+---------------------------------------------+


Step-by-Step Simplest Example


Command Interface
---------------------
public interface Command {
    void execute();
}




2️Receiver – Light
--------------------
public class Light {
    public void turnOn() {
        System.out.println("Light is ON");
    }

    public void turnOff() {
        System.out.println("Light is OFF");
    }
}


Concrete Command Classes
--------------------------
public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.turnOn();
    }
}


public class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.turnOff();
    }
}


Invoker – RemoteControl
----------------------------
public class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}


Demo – Putting It All Together
---------------------------------
public class CommandPatternDemo {
    public static void main(String[] args) {
        Light light = new Light();

        Command on = new LightOnCommand(light);
        Command off = new LightOffCommand(light);

        RemoteControl remote = new RemoteControl();

        remote.setCommand(on);
        remote.pressButton();  // Output: Light is ON

        remote.setCommand(off);
        remote.pressButton();  // Output: Light is OFF
    }
}

------------------------------------------------------------------------------------------
| Role            | Class Name                          | Responsibility                 |
| --------------- | ----------------------------------- | ------------------------------ |
| Command         | `Command` (interface)               | Defines the `execute()` method |
| ConcreteCommand | `LightOnCommand`, `LightOffCommand` | Implements `execute()`         |
| Receiver        | `Light`                             | Knows how to perform actions   |
| Invoker         | `RemoteControl`                     | Calls `execute()` on command   |
| Client          | `CommandPatternDemo`                | Sets everything up             |

------------------------------------------------------------------------------------------



Interpreter Design Pattern
==========================

	=> Interpreter pattern is one of the behavioral design pattern and 
	is used to defines a grammatical representation for a language and provides 
	an interpreter to deal with this grammar. 

	The best example of this pattern is java compiler that interprets the java 
	source code into byte code that is understandable by JVM. Google Translator


	http://www.journaldev.com/1635/interpreter-design-pattern-in-java-example-tutorial




memento design pattern
=======================
	=> Memento design pattern is used when we want to save the state of an object 
	so that we can restore later on. Memento pattern is used to implement
	 this in such a way that the saved state data of the object is not accessible outside of the object, 
	this protects the integrity of saved state data.


	=> Originator is the object whose state needs to be saved and restored and it uses an inner class to save the
	 state of Object. The inner class is called Memento and it’s private,
	 so that it can’t be accessed from other objects.

	=> Caretaker is the helper class that is responsible for storing and restoring 
	the Originator’s state through Memento object. Since Memento is private to Originator, 
	Caretaker can’t access it and it’s stored as an Object within the caretaker.

	=> Example text editors where we can save it’s data anytime and use undo to restore it to previous saved state

http://www.journaldev.com/1734/memento-design-pattern-java







Mediator
============
	=> Allows loose coupling by encapsulating the way disparate sets of objects 
	interact and communicate with each other.

	=>  Allows for the actions of each object set to vary independently of one another.

	=> Mediator design pattern is very helpful in an enterprise application where 
	multiple objects are interacting with each other. 

	=> If the objects interact with each other directly, the system components are tightly-coupled 
	with each other that makes higher maintainability cost and not hard to extend. 

	=> Mediator pattern focuses on provide a mediator between objects for communication 
	and help in implementing lose-coupling between objects.

	=> Air traffic controller is a great example of mediator pattern where the airport control room 
	works as a mediator for communication between different flights. 
	Mediator works as a router between objects and it can have it’s own logic to provide way of communication.

	=>Other example ESB bus in SOA

http://www.journaldev.com/1730/mediator-design-pattern-java





Selected topics:
-----------------
SOLID
http://cafe.elharo.com/programming/a-square-is-not-a-rectangle/
http://www.cdf.toronto.edu/~csc207h/fall/stg/lectures/eve/w10/
http://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/
http://www.informit.com/store/java-coding-guidelines-75-recommendations-for-reliable-9780321933157


